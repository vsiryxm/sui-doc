
# 访问链上时间

当你需要在交易中获取网络时间时，有两种主要选择：

* 如果你需要接近实时的时间（几秒内的精度），可以使用 Move 中的 `sui::clock::Clock` 模块提供的不可变时间引用。该时间值会随着每个网络检查点自动更新。
* 如果你对当前时间要求不高，也可以使用 `epoch_timestamp_ms` 函数来获取当前 epoch 开始时的精准时间戳。

---

## `sui::clock::Clock` 模块

* 要获取准确的时间戳，必须在交易的入口函数参数中传入一个 **只读引用**（immutable reference）类型的 `&Clock`。
* 系统已在地址 `0x6` 提供了一个 `Clock` 实例，不允许创建新的实例。
* 使用 `sui::clock::timestamp_ms(&clock)` 函数可以获取 **Unix 毫秒级时间戳**。

### 示例：在 Move 模块中使用 `Clock`

参考：[crates/sui-framework/packages/sui-framework/sources/clock.move](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/packages/sui-framework/sources/clock.move)

```move
public fun timestamp_ms(clock: &Clock): u64 {
    clock.timestamp_ms
}
```
下面这个示例演示了一个入口函数，它会发出一个包含来自 Clock 的时间戳的事件：

参考：[examples/move/basics/sources/clock.move](https://github.com/MystenLabs/sui/blob/main/examples/move/basics/sources/clock.move)
```move
module basics::clock;

use sui::clock::Clock;
use sui::event;

public struct TimeEvent has copy, drop, store {
    timestamp_ms: u64,
}
```
调用前面那个入口函数时，形式如下，其中将 **0x6** 作为 **Clock** 参数的地址传入。

调用方式示例：

```bash
$ sui client call --package <EXAMPLE> --module clock --function access --args 0x6 --gas-budget <GAS-AMOUNT>
```

* 随着网络每生成一个检查点（checkpoint）（例如 Mysticeti 共识下约每 1/4 秒， 见[公共仪表板](https://metrics.sui.io/public-dashboards/4ceb11cc210d4025b122294586961169)），`Clock` 的时间戳会更新。
* 同一笔交易中多次调用 `timestamp_ms` 总是返回相同值（交易被视为瞬间生效）。不同交易中访问同一共享对象的时间戳是单调递增的（即后一笔 ≥ 前一笔）。
* 由于 `Clock` 是一个共享对象，任何访问它的交易都必须经过共识，因此不适用于必须使用单一所有者快速路径（fastpath）的交易场景。
* 接受 `Clock` 参数的入口函数必须使用不可变引用（`&Clock`），不能使用可变引用（`&mut Clock`）或值。否则验证器会拒绝签名，且包无法发布。

以下函数通过手动创建一个 **Clock** 对象并操作其时间戳来测试依赖 **Clock** 的代码。
这种做法仅在测试代码中才可能实现。

参考：[crates/sui-framework/packages/sui-framework/sources/clock.move](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/packages/sui-framework/sources/clock.move)

```move
#[test_only]
public fun create_for_testing(ctx: &mut TxContext): Clock {
    Clock {
        id: object::new(ctx),
        timestamp_ms: 0,
    }
}

#[test_only]
public fun share_for_testing(clock: Clock) {
    transfer::share_object(clock)
}

#[test_only]
public fun increment_for_testing(clock: &mut Clock, tick: u64) {
    clock.timestamp_ms = clock.timestamp_ms + tick;
}

#[test_only]
public fun set_for_testing(clock: &mut Clock, timestamp_ms: u64) {
    assert!(timestamp_ms >= clock.timestamp_ms);
    clock.timestamp_ms = timestamp_ms;
}

#[test_only]
public fun destroy_for_testing(clock: Clock) {
    let Clock { id, timestamp_ms: _ } = clock;
    id.delete();
}
```

测试相关函数说明：
* `create_for_testing(ctx: &mut TxContext): Clock` — 创建一个 `Clock` 实例
* `share_for_testing(clock: Clock)` — 将 `Clock` 对象设为共享
* `increment_for_testing(clock: &mut Clock, tick: u64)` — 增加时间戳
* `set_for_testing(clock: &mut Clock, timestamp_ms: u64)` — 设置时间戳（新值必须 ≥ 当前值）
* `destroy_for_testing(clock: Clock)` — 销毁 `Clock` 对象
  

下一个示例展示了一个基础测试：它创建一个 `Clock`，对其递增，然后检查其值：

参考：[crates/sui-framework/packages/sui-framework/tests/clock_tests.move](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/packages/sui-framework/tests/clock_tests.move)

```move
#[test_only]
module sui::clock_tests;

use sui::clock;

#[test]
fun creating_a_clock_and_incrementing_it() {
    let mut ctx = tx_context::dummy();
    let mut clock = clock::create_for_testing(&mut ctx);

    clock.increment_for_testing(42);
    assert!(clock.timestamp_ms() == 42);

    clock.set_for_testing(50);
    assert!(clock.timestamp_ms() == 50);

    clock.destroy_for_testing();
}
```

## Epoch 时间戳（Epoch Timestamps）

如果你希望获取当前 epoch 开始的时间戳，包括不经过共识流程的交易，可使用：

参考：[crates/sui-framework/packages/sui-framework/sources/tx_context.move](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/packages/sui-framework/sources/tx_context.move)
```move
public fun epoch_timestamp_ms(_self: &TxContext): u64 {
    native_epoch_timestamp_ms()
}
```

上面这个函数返回的是 **当前 epoch 开始时的时间点**，以毫秒为单位的 Unix 时间戳，类型为 `u64`。该时间值大约每 24 小时（即每当 epoch 更迭时）更新一次。

在使用 `sui::test_scenario` 模块进行测试时，如果你的代码依赖于 `epoch_timestamp_ms` 的时间逻辑，可以利用 `later_epoch` 函数来**模拟时间推进并触发相应逻辑**：

```move
public fun later_epoch(
    scenario: &mut Scenario,
    delta_ms: u64,
    sender: address,
): TransactionEffects {
    scenario.ctx.increment_epoch_timestamp(delta_ms);
    next_epoch(scenario, sender)
}
```

该函数的行为类似于 `sui::test_scenario::next_epoch`（它会结束当前交易并推进测试场景中的 epoch ），但额外会将时间戳增加 `delta_ms` 毫秒，从而模拟时间流逝。

---

**参考：**

https://docs.sui.io/guides/developer/sui-101/access-time

https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/packages/sui-framework/sources/clock.move