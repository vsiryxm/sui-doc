
# 签名与发送交易（Signing and Sending Transactions）

Sui 上的交易用于调用具体功能（例如智能合约函数），并根据输入产生相应状态变化。

**交易输入（Inputs）** 可以是对象引用（如拥有的对象、不可变对象或共享对象），也可以是编码值（例如用作 Move 函数参数的字节数组）。在构造交易（通常通过可编程交易块 PTB）后，用户需对其签名并提交到链上执行。

签名使用钱包私钥生成，并且其公钥必须与交易发送者的 Sui 地址一致。

Sui 使用 `SuiKeyPair` 对交易数据进行签名，该签名针对的是意图消息的 Blake2b 哈希摘要（`intent || bcs bytes of tx_data`）。当前支持的签名方案包括：**Ed25519 Pure**、**ECDSA Secp256k1**、**ECDSA Secp256r1**、**多签（Multisig）** 和 **zkLogin**。
你可以使用 `SuiKeyPair` 创建 Ed25519 或 ECDSA 签名，并使用它来签署交易。若使用 [Multisig](https://docs.sui.io/concepts/cryptography/transaction-auth/multisig) 或 [zkLogin](https://docs.sui.io/concepts/cryptography/zklogin)，则需参照对应指南操作。
签名完成后，你可以将签名与交易数据一起提交执行。

## 流程概览

1. 构造交易数据，通常通过编写 `Transaction` 并在其中链式添加多个操作。详细信息请参考“[构建可编程交易块（PTB）](https://docs.sui.io/guides/developer/sui-101/building-ptb)”章节。
2. 使用 SDK 自动估算 gas 并选择 gas coin。
3. 对交易进行签名生成签名。
4. 将交易与签名一起提交链上执行。

> 小提示：如果你希望使用指定的 gas coin，需先找到该 coin 的对象 ID，并在 PTB 构造中显式使用它。如果当前没有 gas coin，可以先使用 [splitCoin](https://docs.sui.io/guides/developer/sui-101/building-ptb#available-transactions) 交易创建一个；该交易应放在 PTB 的第一个位置。

---

## 开发示例

以下分别展示了通过 TypeScript、Rust 或 Sui CLI 完成签名并执行交易的示例。

有多种方法可以实例化密钥对并使用 Sui TypeScript SDK 派生其公钥和 Sui 地址。

### TypeScript 示例
```typescript
import { fromHex } from '@mysten/bcs';
import { getFullnodeUrl, SuiClient } from '@mysten/sui/client';
import { type Keypair } from '@mysten/sui/cryptography';
import { Ed25519Keypair } from '@mysten/sui/keypairs/ed25519';
import { Secp256k1Keypair } from '@mysten/sui/keypairs/secp256k1';
import { Secp256r1Keypair } from '@mysten/sui/keypairs/secp256r1';
import { Transaction } from '@mysten/sui/transactions';

const kp_rand_0 = new Ed25519Keypair();
const kp_rand_1 = new Secp256k1Keypair();
const kp_rand_2 = new Secp256r1Keypair();

const kp_import_0 = Ed25519Keypair.fromSecretKey(
	fromHex('0xd463e11c7915945e86ac2b72d88b8190cfad8ff7b48e7eb892c275a5cf0a3e82'),
);
const kp_import_1 = Secp256k1Keypair.fromSecretKey(
	fromHex('0xd463e11c7915945e86ac2b72d88b8190cfad8ff7b48e7eb892c275a5cf0a3e82'),
);
const kp_import_2 = Secp256r1Keypair.fromSecretKey(
	fromHex('0xd463e11c7915945e86ac2b72d88b8190cfad8ff7b48e7eb892c275a5cf0a3e82'),
);

// $MNEMONICS 指的是由 12/15/18/21/24 个单词组成的助记词，例如：
// retire skin goose will hurry this field stadium drastic label husband venture cruel toe wire
// 更多信息请参考 https://docs.sui.io/concepts/cryptography/transaction-auth/keys-addresses
const kp_derive_0 = Ed25519Keypair.deriveKeypair('$MNEMONICS');
const kp_derive_1 = Secp256k1Keypair.deriveKeypair('$MNEMONICS');
const kp_derive_2 = Secp256r1Keypair.deriveKeypair('$MNEMONICS');

const kp_derive_with_path_0 = Ed25519Keypair.deriveKeypair('$MNEMONICS', "m/44'/784'/1'/0'/0'");
const kp_derive_with_path_1 = Secp256k1Keypair.deriveKeypair('$MNEMONICS', "m/54'/784'/1'/0/0");
const kp_derive_with_path_2 = Secp256r1Keypair.deriveKeypair('$MNEMONICS', "m/74'/784'/1'/0/0");

// 将 `kp_rand_0` 替换为上面的变量名
const pk = kp_rand_0.getPublicKey();
const sender = pk.toSuiAddress();

// 创建一个示例交易块
const txb = new Transaction();
txb.setSender(sender);
txb.setGasPrice(5);
txb.setGasBudget(100);
const bytes = await txb.build();
const serializedSignature = (await keypair.signTransaction(bytes)).signature;

// 在本地验证签名
expect(await keypair.getPublicKey().verifyTransaction(bytes, serializedSignature)).toEqual(true);

// 定义 sui 客户端
const client = new SuiClient({ url: getFullnodeUrl('testnet') });

// execute transaction.
let res = client.executeTransactionBlock({
	transactionBlock: bytes,
	signature: serializedSignature,
});
console.log(res);
```

### Rust 示例

下面的完整代码示例可以在 [crates/sui-sdk](https://github.com/MystenLabs/sui/blob/main/crates/sui-sdk/examples/sign_tx_guide.rs) 下找到。

有多种方法可以实例化 `SuiKeyPair` 并使用 Sui Rust SDK 派生其公钥和 Sui 地址。

```rust
// 确定性地生成密钥对，仅进行测试，不要用于主网，如需随机生成密钥对，请参考下一节内容
let skp_determ_0 =
    SuiKeyPair::Ed25519(Ed25519KeyPair::generate(&mut StdRng::from_seed([0; 32])));
let _skp_determ_1 =
    SuiKeyPair::Secp256k1(Secp256k1KeyPair::generate(&mut StdRng::from_seed([0; 32])));
let _skp_determ_2 =
    SuiKeyPair::Secp256r1(Secp256r1KeyPair::generate(&mut StdRng::from_seed([0; 32])));

// 随机生成一个密钥对
let _skp_rand_0 = SuiKeyPair::Ed25519(get_key_pair_from_rng(&mut rand::rngs::OsRng).1);
let _skp_rand_1 = SuiKeyPair::Secp256k1(get_key_pair_from_rng(&mut rand::rngs::OsRng).1);
let _skp_rand_2 = SuiKeyPair::Secp256r1(get_key_pair_from_rng(&mut rand::rngs::OsRng).1);

// 从 base64 编码的 32 字节私钥导入密钥对
let _skp_import_no_flag_0 = SuiKeyPair::Ed25519(Ed25519KeyPair::from_bytes(
    &Base64::decode("1GPhHHkVlF6GrCty2IuBkM+tj/e0jn64ksJ1pc8KPoI=")
        .map_err(|_| anyhow!("Invalid base64"))?,
)?);
let _skp_import_no_flag_1 = SuiKeyPair::Ed25519(Ed25519KeyPair::from_bytes(
    &Base64::decode("1GPhHHkVlF6GrCty2IuBkM+tj/e0jn64ksJ1pc8KPoI=")
        .map_err(|_| anyhow!("Invalid base64"))?,
)?);
let _skp_import_no_flag_2 = SuiKeyPair::Ed25519(Ed25519KeyPair::from_bytes(
    &Base64::decode("1GPhHHkVlF6GrCty2IuBkM+tj/e0jn64ksJ1pc8KPoI=")
        .map_err(|_| anyhow!("Invalid base64"))?,
)?);

// 从 Base64 编码的 33 字节 `flag || private key` 中导入一个密钥对。签名方案由 flag 决定
let _skp_import_with_flag_0 =
    SuiKeyPair::decode_base64("ANRj4Rx5FZRehqwrctiLgZDPrY/3tI5+uJLCdaXPCj6C")
        .map_err(|_| anyhow!("Invalid base64"))?;
let _skp_import_with_flag_1 =
    SuiKeyPair::decode_base64("AdRj4Rx5FZRehqwrctiLgZDPrY/3tI5+uJLCdaXPCj6C")
        .map_err(|_| anyhow!("Invalid base64"))?;
let _skp_import_with_flag_2 =
    SuiKeyPair::decode_base64("AtRj4Rx5FZRehqwrctiLgZDPrY/3tI5+uJLCdaXPCj6C")
        .map_err(|_| anyhow!("Invalid base64"))?;

// 用上面的变量名替换 skp_determ_0
let pk = skp_determ_0.public();
let sender = SuiAddress::from(&pk);
```

接下来，使用一个示例 PTB 区块（包含默认 Gas 币、Gas 预算和 Gas 价格）构建交易数据并进行签名。更多信息，请参阅[构建 PTB 区块](https://docs.sui.io/guides/developer/sui-101/building-ptb)。

```rust
// 构建一个 PTB 示例
let pt = {
    let mut builder = ProgrammableTransactionBuilder::new();
    builder.pay_sui(vec![sender], vec![1])?;
    builder.finish()
};

let gas_budget = 5_000_000;
let gas_price = sui_client.read_api().get_reference_gas_price().await?;

// 构建交易数据
let tx_data = TransactionData::new_programmable(
    sender,
    vec![gas_coin.object_ref()],
    pt,
    gas_budget,
    gas_price,
);
```

将签名提交给意图消息的 Blake2b 哈希摘要（`intent || bcs bytes of tx_data`）。

```rust
// 导出密钥对应该签名的摘要，即对 `intent || tx_data` 进行 blake2b 哈希
let intent_msg = IntentMessage::new(Intent::sui_transaction(), tx_data);
let raw_tx = bcs::to_bytes(&intent_msg).expect("bcs should not fail");
let mut hasher = sui_types::crypto::DefaultHash::default();
hasher.update(raw_tx.clone());
let digest = hasher.finalize().digest;

// 使用 SuiKeyPair 签署摘要
let sui_sig = skp_determ_0.sign(&digest);

// 如果你想在提交之前在本地验证签名，请使用此功能。如果本地验证失败，则交易将无法在 Sui 中执行
let res = sui_sig.verify_secure(
    &intent_msg,
    sender,
    sui_types::crypto::SignatureScheme::ED25519,
);
assert!(res.is_ok());
```

最后，提交带有签名的交易：

```rust
let transaction_response = sui_client
    .quorum_driver_api()
    .execute_transaction_block(
        sui_types::transaction::Transaction::from_generic_sig_data(
            intent_msg.value,
            Intent::sui_transaction(),
            vec![GenericSignature::Signature(sui_sig)],
        ),
        SuiTransactionBlockResponseOptions::default(),
        None,
    )
    .await?;
```

### Sui CLI 示例

当你第一次使用 **Sui CLI** 时，它会在你本机的 `~/.sui/keystore` 中创建一个本地文件，其中保存了一组私钥（编码格式为：`Base64(flag || 32-byte-private-key)`）。

你可以通过指定其地址，使用任意一个私钥来对交易进行签名。
执行 `sui keytool list` 可以查看地址列表。

初始化密钥有三种方式：
```bash
# 随机生成
sui client new-address ed25519
sui client new-address secp256k1
sui client new-address secp256r1

# 将 32 字节私钥导入密钥库
sui keytool import "0xd463e11c7915945e86ac2b72d88b8190cfad8ff7b48e7eb892c275a5cf0a3e82" ed25519
sui keytool import "0xd463e11c7915945e86ac2b72d88b8190cfad8ff7b48e7eb892c275a5cf0a3e82" secp256k1
sui keytool import "0xd463e11c7915945e86ac2b72d88b8190cfad8ff7b48e7eb892c275a5cf0a3e82" secp256r1

# 将助记词（恢复短语）及其派生路径导入密钥库
# $MNEMONICS 指的是由 12/15/18/21/24 个单词组成的助记词，例如：
# retire skin goose will hurry this field stadium drastic label husband venture cruel toe wire
# 更多信息请参考 https://docs.sui.io/concepts/cryptography/transaction-auth/keys-addresses
sui keytool import "$MNEMONICS" ed25519
sui keytool import "$MNEMONICS" secp256k1
sui keytool import "$MNEMONICS" secp256r1
```

在 CLI 中创建一笔转账交易。

* `$SUI_ADDRESS`：设置为用于签名的密钥对所对应的地址。
* `$GAS_COIN_ID`：指代发送方所拥有、用作 gas 的对象 ID。
* `$GAS_BUDGET`：指执行交易时使用的预算。

随后使用与发送方地址对应的私钥对交易进行签名。

* `$MNEMONICS`：指助记词，由 12/15/18/21/24 个单词组成，例如：
  `retire skin goose will hurry this field stadium drastic label husband venture cruel toe wire`

更多信息请参考 [密钥和地址文档](https://docs.sui.io/concepts/cryptography/transaction-auth/keys-addresses)。

> 小提示：从 Sui v1.24.1 版本开始，CLI 命令不再需要 --gas-budget 选项。

```bash
sui client gas

sui client transfer-sui --to $SUI_ADDRESS --sui-coin-object-id $GAS_COIN_ID --gas-budget $GAS_BUDGET --serialize-unsigned-transaction

sui keytool sign --address $SUI_ADDRESS --data $TX_BYTES

sui client execute-signed-tx --tx-bytes $TX_BYTES --signatures $SERIALIZED_SIGNATURE
```

## 注意事项

1. 本指南演示的是如何使用单一私钥进行签名。如果你需要更复杂的签名策略，请参考 [Multisig（多重签名）](https://docs.sui.io/concepts/cryptography/transaction-auth/multisig)。
2. 类似地，原生 **zkLogin** 并不遵循上述步骤。请查阅[相关文档](https://docs.sui.io/concepts/cryptography/zklogin)，了解如何推导出 zkLogin 地址，并使用临时密钥对生成 zkLogin 签名。
3. 如果你决定自己实现签名机制，而不是使用前面提到的工具，请参阅 [Signatures（签名）](https://docs.sui.io/concepts/cryptography/transaction-auth/signatures) 文档，了解每种签名方案所接受的签名规范。
4. **Flag** 是一个区分不同签名方案的单字节标识。请在 [Signatures 文档](https://docs.sui.io/concepts/cryptography/transaction-auth/signatures)中查看支持的方案及其对应的 flag。
5. `execute_transaction_block` 接口接收一个签名列表，因此其中应当只包含一个用户签名。除非你在使用 **赞助交易（Sponsored Transaction）**，此时可以额外提供一个 gas 对象的签名。更多信息请参见 [Sponsored Transactions 文档](https://docs.sui.io/concepts/transactions/sponsored-transactions)。

---

原文：https://docs.sui.io/guides/developer/sui-101/sign-and-send-txn